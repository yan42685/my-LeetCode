<p>ç»™ä½ ä¸€ä¸ª<code>points</code>&nbsp;æ•°ç»„ï¼Œè¡¨ç¤º 2D å¹³é¢ä¸Šçš„ä¸€äº›ç‚¹ï¼Œå…¶ä¸­&nbsp;<code>points[i] = [x<sub>i</sub>, y<sub>i</sub>]</code>&nbsp;ã€‚</p>

<p>è¿æ¥ç‚¹&nbsp;<code>[x<sub>i</sub>, y<sub>i</sub>]</code> å’Œç‚¹&nbsp;<code>[x<sub>j</sub>, y<sub>j</sub>]</code>&nbsp;çš„è´¹ç”¨ä¸ºå®ƒä»¬ä¹‹é—´çš„ <strong>æ›¼å“ˆé¡¿è·ç¦»</strong>&nbsp;ï¼š<code>|x<sub>i</sub> - x<sub>j</sub>| + |y<sub>i</sub> - y<sub>j</sub>|</code>&nbsp;ï¼Œå…¶ä¸­&nbsp;<code>|val|</code>&nbsp;è¡¨ç¤º&nbsp;<code>val</code>&nbsp;çš„ç»å¯¹å€¼ã€‚</p>

<p>è¯·ä½ è¿”å›å°†æ‰€æœ‰ç‚¹è¿æ¥çš„æœ€å°æ€»è´¹ç”¨ã€‚åªæœ‰ä»»æ„ä¸¤ç‚¹ä¹‹é—´ <strong>æœ‰ä¸”ä»…æœ‰</strong>&nbsp;ä¸€æ¡ç®€å•è·¯å¾„æ—¶ï¼Œæ‰è®¤ä¸ºæ‰€æœ‰ç‚¹éƒ½å·²è¿æ¥ã€‚</p>

<p>&nbsp;</p>

<p><strong>ç¤ºä¾‹ 1ï¼š</strong></p>

<p><img alt="" src="https://assets.leetcode.com/uploads/2020/08/26/d.png" style="height:268px; width:214px; background:#e5e5e5" /></p>

<pre>
<strong>è¾“å…¥ï¼š</strong>points = [[0,0],[2,2],[3,10],[5,2],[7,0]]
<strong>è¾“å‡ºï¼š</strong>20
<strong>è§£é‡Šï¼š
</strong><img alt="" src="https://assets.leetcode.com/uploads/2020/08/26/c.png" style="height:268px; width:214px; background:#e5e5e5" />
æˆ‘ä»¬å¯ä»¥æŒ‰ç…§ä¸Šå›¾æ‰€ç¤ºè¿æ¥æ‰€æœ‰ç‚¹å¾—åˆ°æœ€å°æ€»è´¹ç”¨ï¼Œæ€»è´¹ç”¨ä¸º 20 ã€‚
æ³¨æ„åˆ°ä»»æ„ä¸¤ä¸ªç‚¹ä¹‹é—´åªæœ‰å”¯ä¸€ä¸€æ¡è·¯å¾„äº’ç›¸åˆ°è¾¾ã€‚
</pre>

<p><strong>ç¤ºä¾‹ 2ï¼š</strong></p>

<pre>
<strong>è¾“å…¥ï¼š</strong>points = [[3,12],[-2,5],[-4,1]]
<strong>è¾“å‡ºï¼š</strong>18
</pre>

<p><strong>ç¤ºä¾‹ 3ï¼š</strong></p>

<pre>
<strong>è¾“å…¥ï¼š</strong>points = [[0,0],[1,1],[1,0],[-1,1]]
<strong>è¾“å‡ºï¼š</strong>4
</pre>

<p><strong>ç¤ºä¾‹ 4ï¼š</strong></p>

<pre>
<strong>è¾“å…¥ï¼š</strong>points = [[-1000000,-1000000],[1000000,1000000]]
<strong>è¾“å‡ºï¼š</strong>4000000
</pre>

<p><strong>ç¤ºä¾‹ 5ï¼š</strong></p>

<pre>
<strong>è¾“å…¥ï¼š</strong>points = [[0,0]]
<strong>è¾“å‡ºï¼š</strong>0
</pre>

<p>&nbsp;</p>

<p><strong>æç¤ºï¼š</strong></p>

<ul> 
 <li><code>1 &lt;= points.length &lt;= 1000</code></li> 
 <li><code>-10<sup>6</sup>&nbsp;&lt;= x<sub>i</sub>, y<sub>i</sub> &lt;= 10<sup>6</sup></code></li> 
 <li>æ‰€æœ‰ç‚¹&nbsp;<code>(x<sub>i</sub>, y<sub>i</sub>)</code>&nbsp;ä¸¤ä¸¤ä¸åŒã€‚</li> 
</ul>

<details><summary><strong>Related Topics</strong></summary>å¹¶æŸ¥é›† | å›¾ | æ•°ç»„ | æœ€å°ç”Ÿæˆæ ‘</details><br>

<div>ğŸ‘ 299, ğŸ‘ 0<span style='float: right;'><span style='color: gray;'><a href='https://github.com/labuladong/fucking-algorithm/discussions/939' target='_blank' style='color: lightgray;text-decoration: underline;'>bug åé¦ˆ</a> | <a href='https://labuladong.gitee.io/article/fname.html?fname=jbæ’ä»¶ç®€ä»‹' target='_blank' style='color: lightgray;text-decoration: underline;'>ä½¿ç”¨æŒ‡å—</a> | <a href='https://labuladong.github.io/algo/images/others/%E5%85%A8%E5%AE%B6%E6%A1%B6.jpg' target='_blank' style='color: lightgray;text-decoration: underline;'>æ›´å¤šé…å¥—æ’ä»¶</a></span></span></div>

<div id="labuladong"><hr>

**é€šçŸ¥ï¼š[æ•°æ®ç»“æ„ç²¾å“è¯¾](https://aep.h5.xeknow.com/s/1XJHEO) å’Œ [é€’å½’ç®—æ³•ä¸“é¢˜è¯¾](https://aep.xet.tech/s/3YGcq3) é™æ—¶é™„èµ ç½‘ç«™ä¼šå‘˜ï¼Œå…¨æ–°çº¸è´¨ä¹¦[ã€Šlabuladong çš„ç®—æ³•ç¬”è®°ã€‹](https://labuladong.gitee.io/algo/images/book/book_intro_qrcode.jpg) å‡ºç‰ˆï¼Œç­¾åç‰ˆé™æ—¶åŠä»·ï¼**



<p><strong><a href="https://labuladong.gitee.io/article/slug.html?slug=min-cost-to-connect-all-points" target="_blank">â­ï¸labuladong é¢˜è§£</a></strong></p>
<details><summary><strong>labuladong æ€è·¯</strong></summary>

## åŸºæœ¬æ€è·¯

å¾ˆæ˜¾ç„¶è¿™ä¹Ÿæ˜¯ä¸€ä¸ªæ ‡å‡†çš„æœ€å°ç”Ÿæˆæ ‘é—®é¢˜ï¼šæ¯ä¸ªç‚¹å°±æ˜¯æ— å‘åŠ æƒå›¾ä¸­çš„èŠ‚ç‚¹ï¼Œè¾¹çš„æƒé‡å°±æ˜¯æ›¼å“ˆé¡¿è·ç¦»ï¼Œè¿æ¥æ‰€æœ‰ç‚¹çš„æœ€å°è´¹ç”¨å°±æ˜¯æœ€å°ç”Ÿæˆæ ‘çš„æƒé‡å’Œã€‚

æ‰€ä»¥è§£æ³•æ€è·¯å°±æ˜¯å…ˆç”Ÿæˆæ‰€æœ‰çš„è¾¹ä»¥åŠæƒé‡ï¼Œç„¶åå¯¹è¿™äº›è¾¹æ‰§è¡Œ Kruskal ç®—æ³•å³å¯ã€‚

è¿™é“é¢˜åšäº†ä¸€ä¸ªå°çš„å˜é€šï¼šæ¯ä¸ªåæ ‡ç‚¹æ˜¯ä¸€ä¸ªäºŒå…ƒç»„ï¼Œé‚£ä¹ˆæŒ‰ç†è¯´åº”è¯¥ç”¨äº”å…ƒç»„è¡¨ç¤ºä¸€æ¡å¸¦æƒé‡çš„è¾¹ï¼Œä½†è¿™æ ·çš„è¯ä¸ä¾¿æ‰§è¡Œ Union-Find ç®—æ³•ï¼›æ‰€ä»¥æˆ‘ä»¬ç”¨ `points` æ•°ç»„ä¸­çš„ç´¢å¼•ä»£è¡¨æ¯ä¸ªåæ ‡ç‚¹ï¼Œè¿™æ ·å°±å¯ä»¥ç›´æ¥å¤ç”¨ä¹‹å‰çš„ Kruskal ç®—æ³•é€»è¾‘äº†ã€‚

**è¯¦ç»†é¢˜è§£ï¼š[Kruskal æœ€å°ç”Ÿæˆæ ‘ç®—æ³•](https://labuladong.github.io/article/fname.html?fname=kruskal)**

**æ ‡ç­¾ï¼š[å›¾è®ºç®—æ³•](https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzAxODQxMDM0Mw==&action=getalbum&album_id=2122000448684457990)ï¼Œå¹¶æŸ¥é›†ç®—æ³•ï¼Œæœ€å°ç”Ÿæˆæ ‘**

## è§£æ³•ä»£ç 

æç¤ºï¼šğŸŸ¢ æ ‡è®°çš„æ˜¯æˆ‘å†™çš„è§£æ³•ä»£ç ï¼ŒğŸ¤– æ ‡è®°çš„æ˜¯ chatGPT ç¿»è¯‘çš„å¤šè¯­è¨€è§£æ³•ä»£ç ã€‚å¦‚æœ‰é”™è¯¯ï¼Œå¯ä»¥ [ç‚¹è¿™é‡Œ](https://github.com/labuladong/fucking-algorithm/issues/1113) åé¦ˆå’Œä¿®æ­£ã€‚

<div class="tab-panel"><div class="tab-nav">
<button data-tab-item="cpp" class="tab-nav-button btn " data-tab-group="default" onclick="switchTab(this)">cppğŸ¤–</button>

<button data-tab-item="python" class="tab-nav-button btn " data-tab-group="default" onclick="switchTab(this)">pythonğŸ¤–</button>

<button data-tab-item="java" class="tab-nav-button btn active" data-tab-group="default" onclick="switchTab(this)">javağŸŸ¢</button>

<button data-tab-item="go" class="tab-nav-button btn " data-tab-group="default" onclick="switchTab(this)">goğŸ¤–</button>

<button data-tab-item="javascript" class="tab-nav-button btn " data-tab-group="default" onclick="switchTab(this)">javascriptğŸ¤–</button>
</div><div class="tab-content">
<div data-tab-item="cpp" class="tab-item " data-tab-group="default"><div class="highlight">

```cpp
// æ³¨æ„ï¼šcpp ä»£ç ç”± chatGPTğŸ¤– æ ¹æ®æˆ‘çš„ java ä»£ç ç¿»è¯‘ï¼Œæ—¨åœ¨å¸®åŠ©ä¸åŒèƒŒæ™¯çš„è¯»è€…ç†è§£ç®—æ³•é€»è¾‘ã€‚
// æœ¬ä»£ç å·²ç»é€šè¿‡åŠ›æ‰£çš„æµ‹è¯•ç”¨ä¾‹ï¼Œåº”è¯¥å¯ç›´æ¥æˆåŠŸæäº¤ã€‚

class UF {
public:
    // è¿é€šåˆ†é‡ä¸ªæ•°
    int count;
    // å­˜å‚¨ä¸€æ£µæ ‘
    vector<int> parent;
    // è®°å½•æ ‘çš„ã€Œé‡é‡ã€
    vector<int> size;

    // n ä¸ºå›¾ä¸­èŠ‚ç‚¹çš„ä¸ªæ•°
    UF(int n) {
        this->count = n;
        parent.resize(n);
        size.resize(n);
        for (int i = 0; i < n; i++) {
            parent[i] = i;
            size[i] = 1;
        }
    }

    // å°†èŠ‚ç‚¹ p å’ŒèŠ‚ç‚¹ q è¿é€š
    void unionn(int p, int q) {
        int rootP = find(p);
        int rootQ = find(q);
        if (rootP == rootQ)
            return;

        // å°æ ‘æ¥åˆ°å¤§æ ‘ä¸‹é¢ï¼Œè¾ƒå¹³è¡¡
        if (size[rootP] > size[rootQ]) {
            parent[rootQ] = rootP;
            size[rootP] += size[rootQ];
        } else {
            parent[rootP] = rootQ;
            size[rootQ] += size[rootP];
        }
        // ä¸¤ä¸ªè¿é€šåˆ†é‡åˆå¹¶æˆä¸€ä¸ªè¿é€šåˆ†é‡
        count--;
    }

    // åˆ¤æ–­èŠ‚ç‚¹ p å’ŒèŠ‚ç‚¹ q æ˜¯å¦è¿é€š
    bool connected(int p, int q) {
        int rootP = find(p);
        int rootQ = find(q);
        return rootP == rootQ;
    }

    // è¿”å›èŠ‚ç‚¹ x çš„è¿é€šåˆ†é‡æ ¹èŠ‚ç‚¹
    int find(int x) {
        while (parent[x] != x) {
            // è¿›è¡Œè·¯å¾„å‹ç¼©
            parent[x] = parent[parent[x]];
            x = parent[x];
        }
        return x;
    }

    // è¿”å›å›¾ä¸­çš„è¿é€šåˆ†é‡ä¸ªæ•°
    int getCount() {
        return this->count;
    }
};

class Solution {
public:
    int minCostConnectPoints(vector<vector<int>>& points) {
        int n = points.size();
        // ç”Ÿæˆæ‰€æœ‰è¾¹åŠæƒé‡
        vector<vector<int>> edges;
        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                int xi = points[i][0], yi = points[i][1];
                int xj = points[j][0], yj = points[j][1];
                // ç”¨åæ ‡ç‚¹åœ¨ points ä¸­çš„ç´¢å¼•è¡¨ç¤ºåæ ‡ç‚¹
                edges.push_back({i, j, abs(xi - xj) + abs(yi - yj)});
            }
        }
        // å°†è¾¹æŒ‰ç…§æƒé‡ä»å°åˆ°å¤§æ’åº
        sort(edges.begin(), edges.end(), [](auto& a, auto& b){
            return a[2] < b[2];
        });
        // æ‰§è¡Œ Kruskal ç®—æ³•
        int mst = 0;
        UF uf(n);
        for (auto& edge : edges) {
            int u = edge[0];
            int v = edge[1];
            int weight = edge[2];
            // è‹¥è¿™æ¡è¾¹ä¼šäº§ç”Ÿç¯ï¼Œåˆ™ä¸èƒ½åŠ å…¥ mst
            if (uf.connected(u, v)) {
                continue;
            }
            // è‹¥è¿™æ¡è¾¹ä¸ä¼šäº§ç”Ÿç¯ï¼Œåˆ™å±äºæœ€å°ç”Ÿæˆæ ‘
            mst += weight;
            uf.unionn(u, v);
        }
        return mst;
    }
};
```

</div></div>

<div data-tab-item="python" class="tab-item " data-tab-group="default"><div class="highlight">

```python
# æ³¨æ„ï¼špython ä»£ç ç”± chatGPTğŸ¤– æ ¹æ®æˆ‘çš„ java ä»£ç ç¿»è¯‘ï¼Œæ—¨åœ¨å¸®åŠ©ä¸åŒèƒŒæ™¯çš„è¯»è€…ç†è§£ç®—æ³•é€»è¾‘ã€‚
# æœ¬ä»£ç å·²ç»é€šè¿‡åŠ›æ‰£çš„æµ‹è¯•ç”¨ä¾‹ï¼Œåº”è¯¥å¯ç›´æ¥æˆåŠŸæäº¤ã€‚

class Solution:
    def minCostConnectPoints(self, points: List[List[int]]) -> int:
        n = len(points)
        # ç”Ÿæˆæ‰€æœ‰è¾¹åŠæƒé‡
        edges = []
        for i in range(n):
            for j in range(i + 1, n):
                xi, yi = points[i][0], points[i][1]
                xj, yj = points[j][0], points[j][1]
                # ç”¨åæ ‡ç‚¹åœ¨ points ä¸­çš„ç´¢å¼•è¡¨ç¤ºåæ ‡ç‚¹
                edges.append([i, j, abs(xi - xj) + abs(yi - yj)])
        # å°†è¾¹æŒ‰ç…§æƒé‡ä»å°åˆ°å¤§æ’åº
        edges.sort(key=lambda x: x[2])
        # æ‰§è¡Œ Kruskal ç®—æ³•
        mst = 0
        uf = UF(n)
        for edge in edges:
            u = edge[0]
            v = edge[1]
            weight = edge[2]
            # è‹¥è¿™æ¡è¾¹ä¼šäº§ç”Ÿç¯ï¼Œåˆ™ä¸èƒ½åŠ å…¥ mst
            if uf.connected(u, v):
                continue
            # è‹¥è¿™æ¡è¾¹ä¸ä¼šäº§ç”Ÿç¯ï¼Œåˆ™å±äºæœ€å°ç”Ÿæˆæ ‘
            mst += weight
            uf.union(u, v)
        return mst

class UF:
    # è¿é€šåˆ†é‡ä¸ªæ•°
    count = 0
    # å­˜å‚¨ä¸€æ£µæ ‘
    parent = []
    # è®°å½•æ ‘çš„ã€Œé‡é‡ã€
    size = []

    def __init__(self, n: int):
        # n ä¸ºå›¾ä¸­èŠ‚ç‚¹çš„ä¸ªæ•°
        self.count = n
        self.parent = [i for i in range(n)]
        self.size = [1] * n

    # å°†èŠ‚ç‚¹ p å’ŒèŠ‚ç‚¹ q è¿é€š
    def union(self, p: int, q: int) -> None:
        root_p = self.find(p)
        root_q = self.find(q)
        if root_p == root_q:
            return

        # å°æ ‘æ¥åˆ°å¤§æ ‘ä¸‹é¢ï¼Œè¾ƒå¹³è¡¡
        if self.size[root_p] > self.size[root_q]:
            self.parent[root_q] = root_p
            self.size[root_p] += self.size[root_q]
        else:
            self.parent[root_p] = root_q
            self.size[root_q] += self.size[root_p]

        # ä¸¤ä¸ªè¿é€šåˆ†é‡åˆå¹¶æˆä¸€ä¸ªè¿é€šåˆ†é‡
        self.count -= 1

    # åˆ¤æ–­èŠ‚ç‚¹ p å’ŒèŠ‚ç‚¹ q æ˜¯å¦è¿é€š
    def connected(self, p: int, q: int) -> bool:
        root_p = self.find(p)
        root_q = self.find(q)
        return root_p == root_q

    # è¿”å›èŠ‚ç‚¹ x çš„è¿é€šåˆ†é‡æ ¹èŠ‚ç‚¹
    def find(self, x: int) -> int:
        while self.parent[x] != x:
            # è¿›è¡Œè·¯å¾„å‹ç¼©
            self.parent[x] = self.parent[self.parent[x]]
            x = self.parent[x]
        return x

    # è¿”å›å›¾ä¸­çš„è¿é€šåˆ†é‡ä¸ªæ•°
    def count(self) -> int:
        return self.count
```

</div></div>

<div data-tab-item="java" class="tab-item active" data-tab-group="default"><div class="highlight">

```java
class Solution {
    public int minCostConnectPoints(int[][] points) {
        int n = points.length;
        // ç”Ÿæˆæ‰€æœ‰è¾¹åŠæƒé‡
        List<int[]> edges = new ArrayList<>();
        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                int xi = points[i][0], yi = points[i][1];
                int xj = points[j][0], yj = points[j][1];
                // ç”¨åæ ‡ç‚¹åœ¨ points ä¸­çš„ç´¢å¼•è¡¨ç¤ºåæ ‡ç‚¹
                edges.add(new int[]{
                        i, j, Math.abs(xi - xj) + Math.abs(yi - yj)
                });
            }
        }
        // å°†è¾¹æŒ‰ç…§æƒé‡ä»å°åˆ°å¤§æ’åº
        Collections.sort(edges, (a, b) -> {
            return a[2] - b[2];
        });
        // æ‰§è¡Œ Kruskal ç®—æ³•
        int mst = 0;
        UF uf = new UF(n);
        for (int[] edge : edges) {
            int u = edge[0];
            int v = edge[1];
            int weight = edge[2];
            // è‹¥è¿™æ¡è¾¹ä¼šäº§ç”Ÿç¯ï¼Œåˆ™ä¸èƒ½åŠ å…¥ mst
            if (uf.connected(u, v)) {
                continue;
            }
            // è‹¥è¿™æ¡è¾¹ä¸ä¼šäº§ç”Ÿç¯ï¼Œåˆ™å±äºæœ€å°ç”Ÿæˆæ ‘
            mst += weight;
            uf.union(u, v);
        }
        return mst;
    }

    class UF {
        // è¿é€šåˆ†é‡ä¸ªæ•°
        private int count;
        // å­˜å‚¨ä¸€æ£µæ ‘
        private int[] parent;
        // è®°å½•æ ‘çš„ã€Œé‡é‡ã€
        private int[] size;

        // n ä¸ºå›¾ä¸­èŠ‚ç‚¹çš„ä¸ªæ•°
        public UF(int n) {
            this.count = n;
            parent = new int[n];
            size = new int[n];
            for (int i = 0; i < n; i++) {
                parent[i] = i;
                size[i] = 1;
            }
        }

        // å°†èŠ‚ç‚¹ p å’ŒèŠ‚ç‚¹ q è¿é€š
        public void union(int p, int q) {
            int rootP = find(p);
            int rootQ = find(q);
            if (rootP == rootQ)
                return;

            // å°æ ‘æ¥åˆ°å¤§æ ‘ä¸‹é¢ï¼Œè¾ƒå¹³è¡¡
            if (size[rootP] > size[rootQ]) {
                parent[rootQ] = rootP;
                size[rootP] += size[rootQ];
            } else {
                parent[rootP] = rootQ;
                size[rootQ] += size[rootP];
            }
            // ä¸¤ä¸ªè¿é€šåˆ†é‡åˆå¹¶æˆä¸€ä¸ªè¿é€šåˆ†é‡
            count--;
        }

        // åˆ¤æ–­èŠ‚ç‚¹ p å’ŒèŠ‚ç‚¹ q æ˜¯å¦è¿é€š
        public boolean connected(int p, int q) {
            int rootP = find(p);
            int rootQ = find(q);
            return rootP == rootQ;
        }

        // è¿”å›èŠ‚ç‚¹ x çš„è¿é€šåˆ†é‡æ ¹èŠ‚ç‚¹
        private int find(int x) {
            while (parent[x] != x) {
                // è¿›è¡Œè·¯å¾„å‹ç¼©
                parent[x] = parent[parent[x]];
                x = parent[x];
            }
            return x;
        }

        // è¿”å›å›¾ä¸­çš„è¿é€šåˆ†é‡ä¸ªæ•°
        public int count() {
            return count;
        }
    }
}
```

</div></div>

<div data-tab-item="go" class="tab-item " data-tab-group="default"><div class="highlight">

```go
// æ³¨æ„ï¼šgo ä»£ç ç”± chatGPTğŸ¤– æ ¹æ®æˆ‘çš„ java ä»£ç ç¿»è¯‘ï¼Œæ—¨åœ¨å¸®åŠ©ä¸åŒèƒŒæ™¯çš„è¯»è€…ç†è§£ç®—æ³•é€»è¾‘ã€‚
// æœ¬ä»£ç ä¸ä¿è¯æ­£ç¡®æ€§ï¼Œä»…ä¾›å‚è€ƒã€‚å¦‚æœ‰ç–‘æƒ‘ï¼Œå¯ä»¥å‚ç…§æˆ‘å†™çš„ java ä»£ç å¯¹æ¯”æŸ¥çœ‹ã€‚

func minCostConnectPoints(points [][]int) int {
    n := len(points)
    // ç”Ÿæˆæ‰€æœ‰è¾¹åŠæƒé‡
    edges := make([][]int, 0)
    for i := 0; i < n; i++ {
        for j := i + 1; j < n; j++ {
            xi, yi := points[i][0], points[i][1]
            xj, yj := points[j][0], points[j][1]
            // ç”¨åæ ‡ç‚¹åœ¨ points ä¸­çš„ç´¢å¼•è¡¨ç¤ºåæ ‡ç‚¹
            edges = append(edges, []int{i, j, abs(xi - xj) + abs(yi - yj)})
        }
    }
    // å°†è¾¹æŒ‰ç…§æƒé‡ä»å°åˆ°å¤§æ’åº
    sort.Slice(edges, func(i, j int) bool {
        return edges[i][2] < edges[j][2]
    })
    // æ‰§è¡Œ Kruskal ç®—æ³•
    mst := 0
    uf := NewUF(n)
    for _, edge := range edges {
        u, v, weight := edge[0], edge[1], edge[2]
        // è‹¥è¿™æ¡è¾¹ä¼šäº§ç”Ÿç¯ï¼Œåˆ™ä¸èƒ½åŠ å…¥ mst
        if uf.connected(u, v) {
            continue
        }
        // è‹¥è¿™æ¡è¾¹ä¸ä¼šäº§ç”Ÿç¯ï¼Œåˆ™å±äºæœ€å°ç”Ÿæˆæ ‘
        mst += weight
        uf.union(u, v)
    }
    return mst
}

func abs(x int) int {
    if x < 0 {
        return -x
    }
    return x
}

type UF struct {
    // è¿é€šåˆ†é‡ä¸ªæ•°
    count int
    // å­˜å‚¨ä¸€æ£µæ ‘
    parent []int
    // è®°å½•æ ‘çš„ã€Œé‡é‡ã€
    size []int
}

// NewUF returns a new UF with n nodes
func NewUF(n int) *UF {
    uf := &UF{}
    uf.count = n
    uf.parent = make([]int, n)
    uf.size = make([]int, n)
    for i := 0; i < n; i++ {
        uf.parent[i] = i
        uf.size[i] = 1
    }
    return uf
}

func (uf *UF) union(p, q int) {
    rootP := uf.find(p)
    rootQ := uf.find(q)
    if rootP == rootQ {
        return
    }
    // å°æ ‘æ¥åˆ°å¤§æ ‘ä¸‹é¢ï¼Œè¾ƒå¹³è¡¡
    if uf.size[rootP] > uf.size[rootQ] {
        uf.parent[rootQ] = rootP
        uf.size[rootP] += uf.size[rootQ]
    } else {
        uf.parent[rootP] = rootQ
        uf.size[rootQ] += uf.size[rootP]
    }
    // ä¸¤ä¸ªè¿é€šåˆ†é‡åˆå¹¶æˆä¸€ä¸ªè¿é€šåˆ†é‡
    uf.count--
}

func (uf *UF) connected(p, q int) bool {
    rootP := uf.find(p)
    rootQ := uf.find(q)
    return rootP == rootQ
}

func (uf *UF) find(x int) int {
    for uf.parent[x] != x {
        // è¿›è¡Œè·¯å¾„å‹ç¼©
        uf.parent[x], x = uf.parent[uf.parent[x]], uf.parent[uf.parent[x]]
    }
    return x
}

func (uf *UF) Count() int {
    return uf.count
}
```

</div></div>

<div data-tab-item="javascript" class="tab-item " data-tab-group="default"><div class="highlight">

```javascript
// æ³¨æ„ï¼šjavascript ä»£ç ç”± chatGPTğŸ¤– æ ¹æ®æˆ‘çš„ java ä»£ç ç¿»è¯‘ï¼Œæ—¨åœ¨å¸®åŠ©ä¸åŒèƒŒæ™¯çš„è¯»è€…ç†è§£ç®—æ³•é€»è¾‘ã€‚
// æœ¬ä»£ç å·²ç»é€šè¿‡åŠ›æ‰£çš„æµ‹è¯•ç”¨ä¾‹ï¼Œåº”è¯¥å¯ç›´æ¥æˆåŠŸæäº¤ã€‚

var minCostConnectPoints = function(points) {
    const n = points.length;
    // ç”Ÿæˆæ‰€æœ‰è¾¹åŠæƒé‡
    let edges = [];
    for (let i = 0; i < n; i++) {
        for (let j = i + 1; j < n; j++) {
            const xi = points[i][0], yi = points[i][1];
            const xj = points[j][0], yj = points[j][1];
            // ç”¨åæ ‡ç‚¹åœ¨ points ä¸­çš„ç´¢å¼•è¡¨ç¤ºåæ ‡ç‚¹
            edges.push([i, j, Math.abs(xi - xj) + Math.abs(yi - yj)]);
        }
    }
    // å°†è¾¹æŒ‰ç…§æƒé‡ä»å°åˆ°å¤§æ’åº
    edges.sort((a, b) => {
        return a[2] - b[2];
    });
    // æ‰§è¡Œ Kruskal ç®—æ³•
    let mst = 0;
    const uf = new UF(n);
    for (let i = 0; i < edges.length; i++) {
        const u = edges[i][0];
        const v = edges[i][1];
        const weight = edges[i][2];
        // è‹¥è¿™æ¡è¾¹ä¼šäº§ç”Ÿç¯ï¼Œåˆ™ä¸èƒ½åŠ å…¥ mst
        if (uf.connected(u, v)) {
            continue;
        }
        // è‹¥è¿™æ¡è¾¹ä¸ä¼šäº§ç”Ÿç¯ï¼Œåˆ™å±äºæœ€å°ç”Ÿæˆæ ‘
        mst += weight;
        uf.union(u, v);
    }
    return mst;
};

class UF {
    // è¿é€šåˆ†é‡ä¸ªæ•°
    count = 0;
    // å­˜å‚¨ä¸€æ£µæ ‘
    parent = [];
    // è®°å½•æ ‘çš„ã€Œé‡é‡ã€
    size = [];

    // n ä¸ºå›¾ä¸­èŠ‚ç‚¹çš„ä¸ªæ•°
    constructor(n) {
        this.count = n;
        this.parent = new Array(n).fill(0).map((_, index) => index);
        this.size = new Array(n).fill(1);
    }

    // å°†èŠ‚ç‚¹ p å’ŒèŠ‚ç‚¹ q è¿é€š
    union(p, q) {
        let rootP = this.find(p);
        let rootQ = this.find(q);
        if (rootP == rootQ)
            return;

        // å°æ ‘æ¥åˆ°å¤§æ ‘ä¸‹é¢ï¼Œè¾ƒå¹³è¡¡
        if (this.size[rootP] > this.size[rootQ]) {
            this.parent[rootQ] = rootP;
            this.size[rootP] += this.size[rootQ];
        } else {
            this.parent[rootP] = rootQ;
            this.size[rootQ] += this.size[rootP];
        }
        // ä¸¤ä¸ªè¿é€šåˆ†é‡åˆå¹¶æˆä¸€ä¸ªè¿é€šåˆ†é‡
        this.count--;
    }

    // åˆ¤æ–­èŠ‚ç‚¹ p å’ŒèŠ‚ç‚¹ q æ˜¯å¦è¿é€š
    connected(p, q) {
        let rootP = this.find(p);
        let rootQ = this.find(q);
        return rootP == rootQ;
    }

    // è¿”å›èŠ‚ç‚¹ x çš„è¿é€šåˆ†é‡æ ¹èŠ‚ç‚¹
    find(x) {
        while (this.parent[x] != x) {
            // è¿›è¡Œè·¯å¾„å‹ç¼©
            this.parent[x] = this.parent[this.parent[x]];
            x = this.parent[x];
        }
        return x;
    }

    // è¿”å›å›¾ä¸­çš„è¿é€šåˆ†é‡ä¸ªæ•°
    count() {
        return this.count;
    }
}
```

</div></div>
</div></div>

**ç±»ä¼¼é¢˜ç›®**ï¼š
  - [1135. æœ€ä½æˆæœ¬è”é€šæ‰€æœ‰åŸå¸‚ ğŸŸ ](/problems/connecting-cities-with-minimum-cost)
  - [261. ä»¥å›¾åˆ¤æ ‘ ğŸŸ ](/problems/graph-valid-tree)

</details>
</div>







