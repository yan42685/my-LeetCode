<p>ç»™ä½ ä¸€ä¸ªç”± <code>n</code> ä¸ªèŠ‚ç‚¹ï¼ˆä¸‹æ ‡ä» 0 å¼€å§‹ï¼‰ç»„æˆçš„æ— å‘åŠ æƒå›¾ï¼Œè¯¥å›¾ç”±ä¸€ä¸ªæè¿°è¾¹çš„åˆ—è¡¨ç»„æˆï¼Œå…¶ä¸­ <code>edges[i] = [a, b]</code> è¡¨ç¤ºè¿æ¥èŠ‚ç‚¹ a å’Œ b çš„ä¸€æ¡æ— å‘è¾¹ï¼Œä¸”è¯¥è¾¹éå†æˆåŠŸçš„æ¦‚ç‡ä¸º <code>succProb[i]</code> ã€‚</p>

<p>æŒ‡å®šä¸¤ä¸ªèŠ‚ç‚¹åˆ†åˆ«ä½œä¸ºèµ·ç‚¹ <code>start</code> å’Œç»ˆç‚¹ <code>end</code> ï¼Œè¯·ä½ æ‰¾å‡ºä»èµ·ç‚¹åˆ°ç»ˆç‚¹æˆåŠŸæ¦‚ç‡æœ€å¤§çš„è·¯å¾„ï¼Œå¹¶è¿”å›å…¶æˆåŠŸæ¦‚ç‡ã€‚</p>

<p>å¦‚æœä¸å­˜åœ¨ä» <code>start</code> åˆ° <code>end</code> çš„è·¯å¾„ï¼Œè¯· <strong>è¿”å› 0</strong> ã€‚åªè¦ç­”æ¡ˆä¸æ ‡å‡†ç­”æ¡ˆçš„è¯¯å·®ä¸è¶…è¿‡ <strong>1e-5 </strong>ï¼Œå°±ä¼šè¢«è§†ä½œæ­£ç¡®ç­”æ¡ˆã€‚</p>

<p>&nbsp;</p>

<p><strong>ç¤ºä¾‹ 1ï¼š</strong></p>

<p><strong><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/07/12/1558_ex1.png" style="height: 186px; width: 187px;" /></strong></p>

<pre><strong>è¾“å…¥ï¼š</strong>n = 3, edges = [[0,1],[1,2],[0,2]], succProb = [0.5,0.5,0.2], start = 0, end = 2
<strong>è¾“å‡ºï¼š</strong>0.25000
<strong>è§£é‡Šï¼š</strong>ä»èµ·ç‚¹åˆ°ç»ˆç‚¹æœ‰ä¸¤æ¡è·¯å¾„ï¼Œå…¶ä¸­ä¸€æ¡çš„æˆåŠŸæ¦‚ç‡ä¸º 0.2 ï¼Œè€Œå¦ä¸€æ¡ä¸º 0.5 * 0.5 = 0.25
</pre>

<p><strong>ç¤ºä¾‹ 2ï¼š</strong></p>

<p><strong><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/07/12/1558_ex2.png" style="height: 186px; width: 189px;" /></strong></p>

<pre><strong>è¾“å…¥ï¼š</strong>n = 3, edges = [[0,1],[1,2],[0,2]], succProb = [0.5,0.5,0.3], start = 0, end = 2
<strong>è¾“å‡ºï¼š</strong>0.30000
</pre>

<p><strong>ç¤ºä¾‹ 3ï¼š</strong></p>

<p><strong><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/07/12/1558_ex3.png" style="height: 191px; width: 215px;" /></strong></p>

<pre><strong>è¾“å…¥ï¼š</strong>n = 3, edges = [[0,1]], succProb = [0.5], start = 0, end = 2
<strong>è¾“å‡ºï¼š</strong>0.00000
<strong>è§£é‡Šï¼š</strong>èŠ‚ç‚¹ 0 å’Œ èŠ‚ç‚¹ 2 ä¹‹é—´ä¸å­˜åœ¨è·¯å¾„
</pre>

<p>&nbsp;</p>

<p><strong>æç¤ºï¼š</strong></p>

<ul> 
 <li><code>2 &lt;= n &lt;= 10^4</code></li> 
 <li><code>0 &lt;= start, end &lt; n</code></li> 
 <li><code>start != end</code></li> 
 <li><code>0 &lt;= a, b &lt; n</code></li> 
 <li><code>a != b</code></li> 
 <li><code>0 &lt;= succProb.length == edges.length &lt;= 2*10^4</code></li> 
 <li><code>0 &lt;= succProb[i] &lt;= 1</code></li> 
 <li>æ¯ä¸¤ä¸ªèŠ‚ç‚¹ä¹‹é—´æœ€å¤šæœ‰ä¸€æ¡è¾¹</li> 
</ul>

<details><summary><strong>Related Topics</strong></summary>å›¾ | æ•°ç»„ | æœ€çŸ­è·¯ | å †ï¼ˆä¼˜å…ˆé˜Ÿåˆ—ï¼‰</details><br>

<div>ğŸ‘ 140, ğŸ‘ 0<span style='float: right;'><span style='color: gray;'><a href='https://github.com/labuladong/fucking-algorithm/discussions/939' target='_blank' style='color: lightgray;text-decoration: underline;'>bug åé¦ˆ</a> | <a href='https://labuladong.gitee.io/article/fname.html?fname=jbæ’ä»¶ç®€ä»‹' target='_blank' style='color: lightgray;text-decoration: underline;'>ä½¿ç”¨æŒ‡å—</a> | <a href='https://labuladong.github.io/algo/images/others/%E5%85%A8%E5%AE%B6%E6%A1%B6.jpg' target='_blank' style='color: lightgray;text-decoration: underline;'>æ›´å¤šé…å¥—æ’ä»¶</a></span></span></div>

<div id="labuladong"><hr>

**é€šçŸ¥ï¼š[æ•°æ®ç»“æ„ç²¾å“è¯¾](https://aep.h5.xeknow.com/s/1XJHEO) å’Œ [é€’å½’ç®—æ³•ä¸“é¢˜è¯¾](https://aep.xet.tech/s/3YGcq3) é™æ—¶é™„èµ ç½‘ç«™ä¼šå‘˜ï¼Œå…¨æ–°çº¸è´¨ä¹¦[ã€Šlabuladong çš„ç®—æ³•ç¬”è®°ã€‹](https://labuladong.gitee.io/algo/images/book/book_intro_qrcode.jpg) å‡ºç‰ˆï¼Œç­¾åç‰ˆé™æ—¶åŠä»·ï¼**



<p><strong><a href="https://labuladong.gitee.io/article/slug.html?slug=path-with-maximum-probability" target="_blank">â­ï¸labuladong é¢˜è§£</a></strong></p>
<details><summary><strong>labuladong æ€è·¯</strong></summary>

## åŸºæœ¬æ€è·¯

è™½ç„¶è¿™é¢˜è®©è®¡ç®—æœ€å¤§å€¼ï¼Œä½†æ˜¯ä¹Ÿå¯ä»¥ç”¨ Dijkstra ç®—æ³•æ¨¡æ¿ï¼Œç”±äº Dijkstra ç®—æ³•èƒŒæ™¯çŸ¥è¯†è¾ƒå¤šï¼Œè¯·çœ‹è¯¦ç»†é¢˜è§£ã€‚

**è¯¦ç»†é¢˜è§£ï¼š[Dijkstra ç®—æ³•æ¨¡æ¿åŠåº”ç”¨](https://labuladong.github.io/article/fname.html?fname=dijkstraç®—æ³•)**

**æ ‡ç­¾ï¼šDijkstra ç®—æ³•ï¼Œ[å›¾è®ºç®—æ³•](https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzAxODQxMDM0Mw==&action=getalbum&album_id=2122000448684457990)ï¼Œæœ€çŸ­è·¯å¾„ç®—æ³•**

## è§£æ³•ä»£ç 

æç¤ºï¼šğŸŸ¢ æ ‡è®°çš„æ˜¯æˆ‘å†™çš„è§£æ³•ä»£ç ï¼ŒğŸ¤– æ ‡è®°çš„æ˜¯ chatGPT ç¿»è¯‘çš„å¤šè¯­è¨€è§£æ³•ä»£ç ã€‚å¦‚æœ‰é”™è¯¯ï¼Œå¯ä»¥ [ç‚¹è¿™é‡Œ](https://github.com/labuladong/fucking-algorithm/issues/1113) åé¦ˆå’Œä¿®æ­£ã€‚

<div class="tab-panel"><div class="tab-nav">
<button data-tab-item="cpp" class="tab-nav-button btn " data-tab-group="default" onclick="switchTab(this)">cppğŸ¤–</button>

<button data-tab-item="python" class="tab-nav-button btn " data-tab-group="default" onclick="switchTab(this)">pythonğŸ¤–</button>

<button data-tab-item="java" class="tab-nav-button btn active" data-tab-group="default" onclick="switchTab(this)">javağŸŸ¢</button>

<button data-tab-item="go" class="tab-nav-button btn " data-tab-group="default" onclick="switchTab(this)">goğŸ¤–</button>

<button data-tab-item="javascript" class="tab-nav-button btn " data-tab-group="default" onclick="switchTab(this)">javascriptğŸ¤–</button>
</div><div class="tab-content">
<div data-tab-item="cpp" class="tab-item " data-tab-group="default"><div class="highlight">

```cpp
// æ³¨æ„ï¼šcpp ä»£ç ç”± chatGPTğŸ¤– æ ¹æ®æˆ‘çš„ java ä»£ç ç¿»è¯‘ï¼Œæ—¨åœ¨å¸®åŠ©ä¸åŒèƒŒæ™¯çš„è¯»è€…ç†è§£ç®—æ³•é€»è¾‘ã€‚
// æœ¬ä»£ç å·²ç»é€šè¿‡åŠ›æ‰£çš„æµ‹è¯•ç”¨ä¾‹ï¼Œåº”è¯¥å¯ç›´æ¥æˆåŠŸæäº¤ã€‚

#include <bits/stdc++.h>
using namespace std;

// struct ä¸å†éœ€è¦å£°æ˜ï¼Œç›´æ¥åœ¨ç»“æ„ä½“å†…è¿›è¡Œå®šä¹‰
class Solution {
public:
    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {
        vector<vector<pair<double, int>>> graph(n);
        for (int i = 0; i < edges.size(); i++) {
            int from = edges[i][0];
            int to = edges[i][1];
            double weight = succProb[i];
            // æ— å‘å›¾å…¶å®å°±æ˜¯åŒå‘å›¾
            graph[from].push_back(make_pair(weight, to));
            graph[to].push_back(make_pair(weight, from));
        }
        return dijkstra(start, end, graph);
    }

    struct State {
        int id;
        double distFromStart;
        State(int id, double distFromStart) : id(id), distFromStart(distFromStart) {}
        bool operator < (const State& rhs) const {
            return distFromStart < rhs.distFromStart;
        }
    };

    double dijkstra(int start, int end, vector<vector<pair<double, int>>>& graph) {
        int V = graph.size();
        vector<double> distTo(V, -1);
        distTo[start] = 1;
        priority_queue<State> pq;
        pq.push(State(start, 1));
        while (!pq.empty()) {
            State curState = pq.top();
            pq.pop();
            int curNodeID = curState.id;
            double curDistFromStart = curState.distFromStart;
            if (curNodeID == end) {
                return curDistFromStart;
            }
            if (curDistFromStart < distTo[curNodeID]) {
                continue;
            }
            for (auto neighbor : graph[curNodeID]) {
                int nextNodeID = neighbor.second;
                double distToNextNode = distTo[curNodeID] * neighbor.first;
                if (distTo[nextNodeID] < distToNextNode) {
                    distTo[nextNodeID] = distToNextNode;
                    pq.push(State(nextNodeID, distToNextNode));
                }
            }
        }
        return 0.0;
    }
};
```

</div></div>

<div data-tab-item="python" class="tab-item " data-tab-group="default"><div class="highlight">

```python
# æ³¨æ„ï¼špython ä»£ç ç”± chatGPTğŸ¤– æ ¹æ®æˆ‘çš„ java ä»£ç ç¿»è¯‘ï¼Œæ—¨åœ¨å¸®åŠ©ä¸åŒèƒŒæ™¯çš„è¯»è€…ç†è§£ç®—æ³•é€»è¾‘ã€‚
# æœ¬ä»£ç å·²ç»é€šè¿‡åŠ›æ‰£çš„æµ‹è¯•ç”¨ä¾‹ï¼Œåº”è¯¥å¯ç›´æ¥æˆåŠŸæäº¤ã€‚

import heapq
from typing import List


class Solution:
    def maxProbability(self, n: int, edges: List[List[int]], succProb: List[float], start: int, end: int) -> float:
        graph = [[] for _ in range(n)]
        for i in range(len(edges)):
            from_, to = edges[i][0], edges[i][1]
            weight = succProb[i]
            graph[from_].append((to, weight))
            graph[to].append((from_, weight))

        return self.dijkstra(start, end, graph)

    class State:
        def __init__(self, id_, distFromStart):
            self.id = id_
            self.distFromStart = distFromStart

        def __lt__(self, other):
            return self.distFromStart > other.distFromStart

    def dijkstra(self, start, end, graph):
        V = len(graph)
        # è®°å½•æœ€çŸ­è·¯å¾„çš„æƒé‡ï¼Œä½ å¯ä»¥ç†è§£ä¸º dp table
        # å®šä¹‰ï¼šdistTo[i] çš„å€¼å°±æ˜¯èŠ‚ç‚¹ start åˆ°è¾¾èŠ‚ç‚¹ i çš„æœ€çŸ­è·¯å¾„æƒé‡
        distTo = [-1] * V
        # dp table åˆå§‹åŒ–ä¸ºæ­£æ— ç©·
        distTo[start] = 1

        # ä¼˜å…ˆçº§é˜Ÿåˆ—ï¼ŒdistFromStart è¾ƒå°çš„æ’åœ¨å‰é¢
        pq = []
        # ä»èµ·ç‚¹ start å¼€å§‹è¿›è¡Œ BFS
        heapq.heappush(pq, self.State(start, 1))

        while pq:
            curState = heapq.heappop(pq)
            curNodeID = curState.id
            curDistFromStart = curState.distFromStart

            # åœ¨è¿™é‡ŒåŠ ä¸€ä¸ªåˆ¤æ–­å°±è¡Œäº†ï¼Œå…¶ä»–ä»£ç ä¸ç”¨æ”¹
            if curNodeID == end:
                return curDistFromStart

            if curDistFromStart < distTo[curNodeID]:
                # å·²ç»æœ‰ä¸€æ¡æ›´çŸ­çš„è·¯å¾„åˆ°è¾¾ curNode èŠ‚ç‚¹äº†
                continue
            # å°† curNode çš„ç›¸é‚»èŠ‚ç‚¹è£…å…¥é˜Ÿåˆ—
            for neighbor in graph[curNodeID]:
                nextNodeID = neighbor[0]
                # çœ‹çœ‹ä» curNode è¾¾åˆ° nextNode çš„è·ç¦»æ˜¯å¦ä¼šæ›´çŸ­
                distToNextNode = distTo[curNodeID] * neighbor[1]
                if distTo[nextNodeID] < distToNextNode:
                    # æ›´æ–° dp table
                    distTo[nextNodeID] = distToNextNode
                    # å°†è¿™ä¸ªèŠ‚ç‚¹ä»¥åŠè·ç¦»æ”¾å…¥é˜Ÿåˆ—
                    heapq.heappush(pq, self.State(nextNodeID, distToNextNode))
        return 0.0
```

</div></div>

<div data-tab-item="java" class="tab-item active" data-tab-group="default"><div class="highlight">

```java
class Solution {
    public double maxProbability(int n, int[][] edges, double[] succProb, int start, int end) {
        List<double[]>[] graph = new LinkedList[n];
        for (int i = 0; i < n; i++) {
            graph[i] = new LinkedList<>();
        }
        // æ„é€ æ— å‘å›¾
        for (int i = 0; i < edges.length; i++) {
            int from = edges[i][0];
            int to = edges[i][1];
            double weight = succProb[i];
            // æ— å‘å›¾å…¶å®å°±æ˜¯åŒå‘å›¾
            graph[from].add(new double[]{(double)to, weight});
            graph[to].add(new double[]{(double)from, weight});
        }
        
        
        return dijkstra(start, end, graph);
    }
    
    class State {
        // å›¾èŠ‚ç‚¹çš„ id
        int id;
        // ä» start èŠ‚ç‚¹åˆ°å½“å‰èŠ‚ç‚¹çš„è·ç¦»
        double distFromStart;

        State(int id, double distFromStart) {
            this.id = id;
            this.distFromStart = distFromStart;
        }
    }
    
    double dijkstra(int start, int end, List<double[]>[] graph) {
        // å›¾ä¸­èŠ‚ç‚¹çš„ä¸ªæ•°
        int V = graph.length;
        // è®°å½•æœ€çŸ­è·¯å¾„çš„æƒé‡ï¼Œä½ å¯ä»¥ç†è§£ä¸º dp table
        // å®šä¹‰ï¼šdistTo[i] çš„å€¼å°±æ˜¯èŠ‚ç‚¹ start åˆ°è¾¾èŠ‚ç‚¹ i çš„æœ€çŸ­è·¯å¾„æƒé‡
        double[] distTo = new double[V];
        // dp table åˆå§‹åŒ–ä¸ºæ­£æ— ç©·
        Arrays.fill(distTo, -1);
        // base caseï¼Œstart åˆ° start çš„æœ€çŸ­è·ç¦»å°±æ˜¯ 0
        distTo[start] = 1;

        // ä¼˜å…ˆçº§é˜Ÿåˆ—ï¼ŒdistFromStart è¾ƒå°çš„æ’åœ¨å‰é¢
        Queue<State> pq = new PriorityQueue<>((a, b) -> {
            return Double.compare(b.distFromStart, a.distFromStart);
        });
        // ä»èµ·ç‚¹ start å¼€å§‹è¿›è¡Œ BFS
        pq.offer(new State(start, 1));

        while (!pq.isEmpty()) {
            State curState = pq.poll();
            int curNodeID = curState.id;
            double curDistFromStart = curState.distFromStart;

            // åœ¨è¿™é‡ŒåŠ ä¸€ä¸ªåˆ¤æ–­å°±è¡Œäº†ï¼Œå…¶ä»–ä»£ç ä¸ç”¨æ”¹
            if (curNodeID == end) {
                return curDistFromStart;
            }
            
            if (curDistFromStart < distTo[curNodeID]) {
                // å·²ç»æœ‰ä¸€æ¡æ›´çŸ­çš„è·¯å¾„åˆ°è¾¾ curNode èŠ‚ç‚¹äº†
                continue;
            }
            // å°† curNode çš„ç›¸é‚»èŠ‚ç‚¹è£…å…¥é˜Ÿåˆ—
            for (double[] neighbor : graph[curNodeID]) {
                int nextNodeID = (int)neighbor[0];
                // çœ‹çœ‹ä» curNode è¾¾åˆ° nextNode çš„è·ç¦»æ˜¯å¦ä¼šæ›´çŸ­
                double distToNextNode = distTo[curNodeID] * neighbor[1];
                if (distTo[nextNodeID] < distToNextNode) {
                    // æ›´æ–° dp table
                    distTo[nextNodeID] = distToNextNode;
                    // å°†è¿™ä¸ªèŠ‚ç‚¹ä»¥åŠè·ç¦»æ”¾å…¥é˜Ÿåˆ—
                    pq.offer(new State(nextNodeID, distToNextNode));
                }
            }
        }
        return 0.0;
    }
}
```

</div></div>

<div data-tab-item="go" class="tab-item " data-tab-group="default"><div class="highlight">

```go
// æ³¨æ„ï¼šgo ä»£ç ç”± chatGPTğŸ¤– æ ¹æ®æˆ‘çš„ java ä»£ç ç¿»è¯‘ï¼Œæ—¨åœ¨å¸®åŠ©ä¸åŒèƒŒæ™¯çš„è¯»è€…ç†è§£ç®—æ³•é€»è¾‘ã€‚
// æœ¬ä»£ç å·²ç»é€šè¿‡åŠ›æ‰£çš„æµ‹è¯•ç”¨ä¾‹ï¼Œåº”è¯¥å¯ç›´æ¥æˆåŠŸæäº¤ã€‚

type State struct {
    id   int
    dist float64
}

func maxProbability(n int, edges [][]int, succProb []float64, start int, end int) float64 {
    graph := make([][]State, n)
    for i := 0; i < n; i++ {
        graph[i] = make([]State, 0)
    }

    // æ„é€ æ— å‘å›¾
    for i := 0; i < len(edges); i++ {
        from := edges[i][0]
        to := edges[i][1]
        weight := succProb[i]
        // æ— å‘å›¾å…¶å®å°±æ˜¯åŒå‘å›¾
        graph[from] = append(graph[from], State{to, weight})
        graph[to] = append(graph[to], State{from, weight})
    }

    return dijkstra(start, end, graph)
}

func dijkstra(start int, end int, graph [][]State) float64 {
    // å›¾ä¸­èŠ‚ç‚¹çš„ä¸ªæ•°
    V := len(graph)
    // è®°å½•æœ€çŸ­è·¯å¾„çš„æƒé‡ï¼Œä½ å¯ä»¥ç†è§£ä¸º dp table
    // å®šä¹‰ï¼šdistTo[i] çš„å€¼å°±æ˜¯èŠ‚ç‚¹ start åˆ°è¾¾èŠ‚ç‚¹ i çš„æœ€çŸ­è·¯å¾„æƒé‡
    distTo := make([]float64, V)
    // dp table åˆå§‹åŒ–ä¸ºæ­£æ— ç©·
    for i := 0; i < V; i++ {
        distTo[i] = -1
    }
    // base caseï¼Œstart åˆ° start çš„æœ€çŸ­è·ç¦»å°±æ˜¯ 0
    distTo[start] = 1

    // ä¼˜å…ˆçº§é˜Ÿåˆ—ï¼ŒdistFromStart è¾ƒå°çš„æ’åœ¨å‰é¢
    pq := make(PriorityQueue, 0)
    heap.Init(&pq)
    //ä»èµ·ç‚¹ start å¼€å§‹è¿›è¡Œ BFS
    heap.Push(&pq, &State{id: start, dist: 1})

    for pq.Len() > 0 {
        curState := heap.Pop(&pq).(*State)
        curNodeID := curState.id
        curDistFromStart := curState.dist

        // åœ¨è¿™é‡ŒåŠ ä¸€ä¸ªåˆ¤æ–­å°±è¡Œäº†ï¼Œå…¶ä»–ä»£ç ä¸ç”¨æ”¹
        if curNodeID == end {
            return curDistFromStart
        }

        if curDistFromStart < distTo[curNodeID] {
            // å·²ç»æœ‰ä¸€æ¡æ›´çŸ­çš„è·¯å¾„åˆ°è¾¾ curNode èŠ‚ç‚¹äº†
            continue
        }
        // å°† curNode çš„ç›¸é‚»èŠ‚ç‚¹è£…å…¥é˜Ÿåˆ—
        for _, neighbor := range graph[curNodeID] {
            nextNodeID := neighbor.id
            // çœ‹çœ‹ä» curNode è¾¾åˆ° nextNode çš„è·ç¦»æ˜¯å¦ä¼šæ›´çŸ­
            distToNextNode := distTo[curNodeID] * neighbor.dist
            if distTo[nextNodeID] < distToNextNode {
                // æ›´æ–° dp table
                distTo[nextNodeID] = distToNextNode
                // å°†è¿™ä¸ªèŠ‚ç‚¹ä»¥åŠè·ç¦»æ”¾å…¥é˜Ÿåˆ—
                heap.Push(&pq, &State{nextNodeID, distToNextNode})
            }
        }
    }
    return 0.0
}

// ä¼˜å…ˆçº§é˜Ÿåˆ—æ•°æ®ç»“æ„ï¼Œç”¨äºå®ç° BFS å¹¿åº¦ä¼˜å…ˆæœç´¢
type PriorityQueue []*State

func (pq PriorityQueue) Len() int {
    return len(pq)
}

func (pq PriorityQueue) Less(i, j int) bool {
    return pq[i].dist > pq[j].dist
}

func (pq PriorityQueue) Swap(i, j int) {
    pq[i], pq[j] = pq[j], pq[i]
}

func (pq *PriorityQueue) Push(x interface{}) {
    item := x.(*State)
    *pq = append(*pq, item)
}

func (pq *PriorityQueue) Pop() interface{} {
    old := *pq
    n := len(old)
    item := old[n-1]
    *pq = old[0 : n-1]
    return item
}
```

</div></div>

<div data-tab-item="javascript" class="tab-item " data-tab-group="default"><div class="highlight">

```javascript
// æ³¨æ„ï¼šjavascript ä»£ç ç”± chatGPTğŸ¤– æ ¹æ®æˆ‘çš„ java ä»£ç ç¿»è¯‘ï¼Œæ—¨åœ¨å¸®åŠ©ä¸åŒèƒŒæ™¯çš„è¯»è€…ç†è§£ç®—æ³•é€»è¾‘ã€‚
// æœ¬ä»£ç ä¸ä¿è¯æ­£ç¡®æ€§ï¼Œä»…ä¾›å‚è€ƒã€‚å¦‚æœ‰ç–‘æƒ‘ï¼Œå¯ä»¥å‚ç…§æˆ‘å†™çš„ java ä»£ç å¯¹æ¯”æŸ¥çœ‹ã€‚

/**
 * @param {number} n
 * @param {number[][]} edges
 * @param {number[]} succProb
 * @param {number} start
 * @param {number} end
 * @return {number}
 */
var maxProbability = function(n, edges, succProb, start, end) {
    const graph = [];
    for (let i = 0; i < n; i++) {
        graph[i] = [];
    }
    // æ„é€ æ— å‘å›¾
    for (let i = 0; i < edges.length; i++) {
        const from = edges[i][0];
        const to = edges[i][1];
        const weight = succProb[i];
        // æ— å‘å›¾å…¶å®å°±æ˜¯åŒå‘å›¾
        graph[from].push([to, weight]);
        graph[to].push([from, weight]);
    }


    return dijkstra(start, end, graph);
};

class State {
    // å›¾èŠ‚ç‚¹çš„ id
    constructor(id, distFromStart) {
        this.id = id;
        // ä» start èŠ‚ç‚¹åˆ°å½“å‰èŠ‚ç‚¹çš„è·ç¦»
        this.distFromStart = distFromStart;
    }
}

function dijkstra(start, end, graph) {
    // å›¾ä¸­èŠ‚ç‚¹çš„ä¸ªæ•°
    const V = graph.length;
    // è®°å½•æœ€çŸ­è·¯å¾„çš„æƒé‡ï¼Œä½ å¯ä»¥ç†è§£ä¸º dp table
    // å®šä¹‰ï¼šdistTo[i] çš„å€¼å°±æ˜¯èŠ‚ç‚¹ start åˆ°è¾¾èŠ‚ç‚¹ i çš„æœ€çŸ­è·¯å¾„æƒé‡
    const distTo = new Array(V).fill(-1);
    // dp table åˆå§‹åŒ–ä¸ºæ­£æ— ç©·
    distTo[start] = 1;

    // ä¼˜å…ˆçº§é˜Ÿåˆ—ï¼ŒdistFromStart è¾ƒå°çš„æ’åœ¨å‰é¢
    const pq = new PriorityQueue((a, b) => {
        return b.distFromStart - a.distFromStart;
    });
    // ä»èµ·ç‚¹ start å¼€å§‹è¿›è¡Œ BFS
    pq.offer(new State(start, 1));

    while (!pq.isEmpty()) {
        const curState = pq.poll();
        const curNodeID = curState.id;
        const curDistFromStart = curState.distFromStart;

        // åœ¨è¿™é‡ŒåŠ ä¸€ä¸ªåˆ¤æ–­å°±è¡Œäº†ï¼Œå…¶ä»–ä»£ç ä¸ç”¨æ”¹
        if (curNodeID === end) {
            return curDistFromStart;
        }

        if (curDistFromStart < distTo[curNodeID]) {
            // å·²ç»æœ‰ä¸€æ¡æ›´çŸ­çš„è·¯å¾„åˆ°è¾¾ curNode èŠ‚ç‚¹äº†
            continue;
        }
        // å°† curNode çš„ç›¸é‚»èŠ‚ç‚¹è£…å…¥é˜Ÿåˆ—
        for (const neighbor of graph[curNodeID]) {
            const nextNodeID = neighbor[0];
            // çœ‹çœ‹ä» curNode è¾¾åˆ° nextNode çš„è·ç¦»æ˜¯å¦ä¼šæ›´çŸ­
            const distToNextNode = distTo[curNodeID] * neighbor[1];
            if (distTo[nextNodeID] < distToNextNode) {
                // æ›´æ–° dp table
                distTo[nextNodeID] = distToNextNode;
                // å°†è¿™ä¸ªèŠ‚ç‚¹ä»¥åŠè·ç¦»æ”¾å…¥é˜Ÿåˆ—
                pq.offer(new State(nextNodeID, distToNextNode));
            }
        }
    }
    return 0.0;
}

class PriorityQueue {
    constructor(compare) {
        this.queue = [];
        this.compare = compare;
    }

    offer(val) {
        this.queue.push(val);
        this.queue.sort(this.compare);
    }

    poll() {
        return this.queue.shift();
    }

    isEmpty() {
        return this.queue.length === 0;
    }
}
```

</div></div>
</div></div>

**ç±»ä¼¼é¢˜ç›®**ï¼š
  - [1631. æœ€å°ä½“åŠ›æ¶ˆè€—è·¯å¾„ ğŸŸ ](/problems/path-with-minimum-effort)
  - [743. ç½‘ç»œå»¶è¿Ÿæ—¶é—´ ğŸŸ ](/problems/network-delay-time)

</details>
</div>

